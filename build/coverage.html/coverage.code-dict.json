{"/home/travis/build/npmtest/node-npmtest-camo/test.js":"/* istanbul instrument in package npmtest_camo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-camo/lib.npmtest_camo.js":"/* istanbul instrument in package npmtest_camo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_camo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_camo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-camo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-camo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_camo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_camo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_camo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_camo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_camo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_camo.__dirname + '/lib.npmtest_camo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/index.js":"'use strict';\n\nexports.connect = require('./lib/db').connect;\nexports.getClient = require('./lib/clients').getClient;\n\nexports.Document = require('./lib/document');\nexports.EmbeddedDocument = require('./lib/embedded-document');\n","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/db.js":"'use strict';\n\nconst NeDbClient = require('./clients/nedbclient');\nconst MongoClient = require('./clients/mongoclient');\n\n/**\n * Connect to current database\n *\n * @param {String} url\n * @param {Object} options\n * @returns {Promise}\n */\nexports.connect = function(url, options) {\n    if (url.indexOf('nedb://') > -1) {\n        // url example: nedb://path/to/file/folder\n        return NeDbClient.connect(url, options).then(function(db) {\n            global.CLIENT = db;\n            return db;\n        });\n    } else if(url.indexOf('mongodb://') > -1) {\n        // url example: 'mongodb://localhost:27017/myproject'\n        return MongoClient.connect(url, options).then(function(db) {\n            global.CLIENT = db;\n            return db;\n        });\n    } else {\n        return Promise.reject(new Error('Unrecognized DB connection url.'));\n    }\n};","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/clients/nedbclient.js":"'use strict';\n\nconst _ = require('lodash');\nconst path = require('path');\nconst fs = require('fs');\nconst Datastore = require('nedb');\nconst DatabaseClient = require('./client');\n\nconst urlToPath = function(url) {\n    if (url.indexOf('nedb://') > -1) {\n        return url.slice(7, url.length);\n    }\n    return url;\n};\n\nconst getCollectionPath = function(dbLocation, collection) {\n    if (dbLocation === 'memory') {\n        return dbLocation;\n    }\n    return path.join(dbLocation, collection) + '.db';\n};\n\nconst createCollection = function(collectionName, url) {\n    if (url === 'memory') {\n        return new Datastore({inMemoryOnly: true});\n    }\n    let collectionPath = getCollectionPath(url, collectionName);\n    return new Datastore({filename: collectionPath, autoload: true});\n};\n\nconst getCollection = function(name, collections, path) {\n    if (!(name in collections)) {\n        let collection = createCollection(name, path);\n        collections[name] = collection;\n        return collection;\n    }\n    \n    return collections[name];\n};\n\nclass NeDbClient extends DatabaseClient {\n    constructor(url, collections) {\n        super(url);\n        this._path = urlToPath(url);\n\n        if (collections) {\n            this._collections = collections;\n        } else {\n            this._collections = {};\n        }\n    }\n\n    /**\n     * Save (upsert) document\n     *\n     * @param {String} collection Collection's name\n     * @param {ObjectId?} id Document's id\n     * @param {Object} values Data for save\n     * @returns {Promise} Promise with result insert or update query\n     */\n    save(collection, id, values) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n\n            // TODO: I'd like to just use update with upsert:true, but I'm\n            // note sure how the query will work if id == null. Seemed to\n            // have some problems before with passing null ids.\n            if (id === null) {\n                db.insert(values, function(error, result) {\n                    if (error) return reject(error);\n                    return resolve(result._id);\n                });\n            } else {\n                db.update({ _id: id }, { $set: values }, { upsert: true }, function(error, result) {\n                    if (error) return reject(error);\n                    return resolve(result);\n                });\n            }\n        });\n    }\n\n    /**\n     * Delete document\n     *\n     * @param {String} collection Collection's name\n     * @param {ObjectId} id Document's id\n     * @returns {Promise}\n     */\n    delete(collection, id) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            if (id === null) resolve(0);\n\n            const db = getCollection(collection, that._collections, that._path);\n            db.remove({ _id: id }, function (error, numRemoved) {\n                if (error) return reject(error);\n                return resolve(numRemoved);\n            });\n        });\n    }\n\n    /**\n     * Delete one document by query\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    deleteOne(collection, query) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            db.remove(query, function (error, numRemoved) {\n                if (error) return reject(error);\n                return resolve(numRemoved);\n            });\n        });\n    }\n\n    /**\n     * Delete many documents by query\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    deleteMany(collection, query) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            db.remove(query, { multi: true }, function (error, numRemoved) {\n                if (error) return reject(error);\n                return resolve(numRemoved);\n            });\n        });\n    }\n\n    /**\n     * Find one document\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    findOne(collection, query) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            db.findOne(query, function (error, result) {\n                if (error) return reject(error);\n                return resolve(result);\n            });\n        });\n    }\n\n    /**\n     * Find one document and update it\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} values\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    findOneAndUpdate(collection, query, values, options) {\n        const that = this;\n\n        if (!options) {\n            options = {};\n        }\n\n        // Since this is 'findOne...' we'll only allow user to update\n        // one document at a time\n        options.multi = false;\n\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n\n            // TODO: Would like to just use 'Collection.update' here, but\n            // it doesn't return objects on update (but will on insert)...\n            /*db.update(query, values, options, function(error, numReplaced, newDoc) {\n                if (error) return reject(error);\n                resolve(newDoc);\n            });*/\n\n            that.findOne(collection, query).then(function(data) {\n                if (!data) {\n                    if (options.upsert) {\n                        return db.insert(values, function(error, result) {\n                            if (error) return reject(error);\n                            return resolve(result);\n                        });\n                    } else {\n                        return resolve(null);\n                    }\n                } else {\n                    return db.update(query, { $set: values }, function(error, result) {\n                        if (error) return reject(error);\n                        \n                        // Fixes issue #55. Remove when NeDB is updated to v1.8+\n                        db.findOne({_id: data._id}, function(error, doc) {\n                            if (error) return reject(error);\n                            resolve(doc);\n                        });\n                    });\n                }\n            });\n        });\n    }\n\n    /**\n     * Find one document and delete it\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    findOneAndDelete(collection, query, options) {\n        const that = this;\n\n        if (!options) {\n            options = {};\n        }\n\n        // Since this is 'findOne...' we'll only allow user to update\n        // one document at a time\n        options.multi = false;\n\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            db.remove(query, options, function (error, numRemoved) {\n                if (error) return reject(error);\n                return resolve(numRemoved);\n            });\n        });\n    }\n\n    /**\n     * Find documents\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    find(collection, query, options) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            let cursor = db.find(query);\n\n            if (options.sort && (_.isArray(options.sort) || _.isString(options.sort))) {\n                let sortOptions = {};\n                if (!_.isArray(options.sort)) {\n                    options.sort = [options.sort];\n                }\n\n                options.sort.forEach(function(s) {\n                    if (!_.isString(s)) return;\n\n                    let sortOrder = 1;\n                    if (s[0] === '-') {\n                        sortOrder = -1;\n                        s = s.substring(1);\n                    }\n                    sortOptions[s] = sortOrder;\n                });\n\n                cursor = cursor.sort(sortOptions);\n            }\n            if (typeof options.skip === 'number') {\n                cursor = cursor.skip(options.skip);\n            }\n            if (typeof options.limit === 'number') {\n                cursor = cursor.limit(options.limit);\n            }\n            cursor.exec(function(error, result) {\n                if (error) return reject(error);\n                return resolve(result);\n            });\n        });\n    }\n\n    /**\n     * Get count of collection by query\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    count(collection, query) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = getCollection(collection, that._collections, that._path);\n            db.count(query, function (error, count) {\n                if (error) return reject(error);\n                return resolve(count);\n            });\n        });\n    }\n\n    /**\n     * Create index\n     *\n     * @param {String} collection Collection's name\n     * @param {String} field Field name\n     * @param {Object} options Options\n     * @returns {Promise}\n     */\n    createIndex(collection, field, options) {\n        options = options || {};\n        options.unique = options.unique || false;\n        options.sparse = options.sparse || false;\n\n        const db = getCollection(collection, this._collections, this._path);\n        db.ensureIndex({fieldName: field, unique: options.unique, sparse: options.sparse});\n    }\n\n    /**\n     * Connect to database\n     *\n     * @param {String} url\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    static connect(url, options) {\n        // Could be directory path or 'memory'\n        let dbLocation = urlToPath(url);\n\n        return new Promise(function(resolve, reject) {\n            let collections = {};\n\n            // TODO: Load all data upfront or on-demand?\n            // Maybe give user the option to load upfront.\n            // But which should we do by default?\n            /*fs.readdir(dbLocation, function(error, files) {\n                files.forEach(function(file) {\n                    let extname = path.extname(file);\n                    let filename = file.split('.')[0];\n                    if (extname === '.db' && filename.length > 0) {\n                        let collectionName = filename;\n                        collections[collectionName] = createCollection(collectionName, dbLocation);\n                    }\n                });\n                global.CLIENT = new NeDbClient(dbLocation, collections);\n                resolve(global.CLIENT);\n            });*/\n            //global.CLIENT = new NeDbClient(dbLocation, collections);\n            resolve(new NeDbClient(dbLocation, collections));\n        });\n    }\n\n    /**\n     * Close current connection\n     *\n     * @returns {Promise}\n     */\n    close() {\n        // Nothing to do for NeDB\n    }\n\n    /**\n     * Drop collection\n     *\n     * @param {String} collection\n     * @returns {Promise}\n     */\n    clearCollection(collection) {\n        return this.deleteMany(collection, {});\n    }\n\n    /**\n     * Drop current database\n     *\n     * @returns {Promise}\n     */\n    dropDatabase() {\n        const that = this;\n\n        let clearPromises = [];\n        _.keys(this._collections).forEach(function(key) {\n            let p = new Promise(function(resolve, reject) {\n                let dbLocation = getCollectionPath(that._path, key);\n\n                if (dbLocation === 'memory') {\n                    // Only exists in memory, so just delete the 'Datastore'\n                    delete that._collections[key];\n                    resolve();\n                } else {\n                    // Delete the file, but only if it exists\n                    fs.stat(dbLocation, function(err, stat) {\n                        if (err === null) {\n                            fs.unlink(dbLocation, function(err) {\n                                if (err) reject(err);\n                                delete that._collections[key];\n                                resolve();\n                            });\n                        } else {\n                            resolve();\n                        }\n                    });\n                }\n            });\n            clearPromises.push(p);\n        });\n\n        return Promise.all(clearPromises);\n    }\n\n    toCanonicalId(id) {\n        return id;\n    }\n\n    // Native ids are the same as NeDB ids\n    isNativeId(value) {\n        return String(value).match(/^[a-zA-Z0-9]{16}$/) !== null;\n    }\n\n    nativeIdType() {\n        return String;\n    }\n\n    driver() {\n        return this._collections;\n    }\n\n}\n\nmodule.exports = NeDbClient;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/clients/client.js":"'use strict';\n\nclass DatabaseClient {\n    constructor(url) {\n        this._url = url;\n    }\n\n    save(collection, query, values) {\n        throw new TypeError('You must override save.');\n    }\n\n    delete(collection) {\n        throw new TypeError('You must override delete.');\n    }\n\n    deleteOne(collection, query) {\n        throw new TypeError('You must override deleteOne.');\n    }\n\n    deleteMany(collection, query) {\n        throw new TypeError('You must override deleteMany.');\n    }\n\n    findOne(collection, query) {\n        throw new TypeError('You must override findOne.');\n    }\n\n    findOneAndUpdate(collection, query, values, options) {\n        throw new TypeError('You must override findOneAndUpdate.');\n    }\n\n    findOneAndDelete(collection, query, options) {\n        throw new TypeError('You must override findOneAndDelete.');\n    }\n\n    find(collection, query, options) {\n        throw new TypeError('You must override findMany.');\n    }\n\n    count(collection, query) {\n        throw new TypeError('You must override count.');\n    }\n\n    createIndex(collection, field, options) {\n        throw new TypeError('You must override createIndex.');\n    }\n\n    static connect(url, options) {\n        throw new TypeError('You must override connect (static).');\n    }\n\n    close() {\n        throw new TypeError('You must override close.');\n    }\n\n    clearCollection(collection) {\n        throw new TypeError('You must override clearCollection.');\n    }\n\n    dropDatabase() {\n        throw new TypeError('You must override dropDatabase.');\n    }\n\n    toCanonicalId(id) {\n        throw new TypeError('You must override toCanonicalId.');\n    }\n\n    isNativeId(value) {\n        throw new TypeError('You must override isNativeId.');\n    }\n\n    toNativeId(id) {\n        return this.nativeIdType()(id);\n    }\n\n    nativeIdType() {\n        throw new TypeError('You must override nativeIdType.');\n    }\n\n    driver() {\n        throw new TypeError('You must override driver.');\n    }\n}\n\nmodule.exports = DatabaseClient;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/clients/mongoclient.js":"'use strict';\n\nconst _ = require('lodash');\nconst path = require('path');\nconst fs = require('fs');\nconst MDBClient = require('mongodb').MongoClient;\nconst ObjectId = require('mongodb').ObjectId;\nconst DatabaseClient = require('./client');\nconst isObject = require('../validate').isObject;\nconst deepTraverse = require('../util').deepTraverse;\n\nclass MongoClient extends DatabaseClient {\n    constructor(url, mongo) {\n        super(url);\n\n        this._mongo = mongo;\n    }\n\n    /**\n     * Save (upsert) document\n     *\n     * @param {String} collection Collection's name\n     * @param {ObjectId?} id Document's id\n     * @param {Object} values Data for save\n     * @returns {Promise} Promise with result insert or update query\n     */\n    save(collection, id, values) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n\n            // TODO: I'd like to just use update with upsert:true, but I'm\n            // note sure how the query will work if id == null. Seemed to\n            // have some problems before with passing null ids.\n            if (id === null) {\n                db.insertOne(values, function(error, result) {\n                    if (error) return reject(error);\n                    if (!result.hasOwnProperty('insertedId') || result.insertedId === null) {\n                        return reject(new Error('Save failed to generate ID for object.'));\n                    }\n\n                    return resolve(result.insertedId);\n                });\n            } else {\n                db.updateOne({ _id: id }, { $set: values }, { upsert: true }, function(error, result) {\n                    if (error) return reject(error);\n                    return resolve();\n                });\n            }\n        });\n    }\n\n    /**\n     * Delete document\n     *\n     * @param {String} collection Collection's name\n     * @param {ObjectId} id Document's id\n     * @returns {Promise}\n     */\n    delete(collection, id) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            if (id === null) resolve(0);\n\n            const db = that._mongo.collection(collection);\n            db.deleteOne({ _id: id }, {w:1}, function (error, result) {\n                if (error) return reject(error);\n                return resolve(result.deletedCount);\n            });\n        });\n    }\n\n    /**\n     * Delete one document by query\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    deleteOne(collection, query) {\n        const that = this;\n        query = castQueryIds(query);\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n            db.deleteOne(query, {w:1}, function (error, result) {\n                if (error) return reject(error);\n                return resolve(result.deletedCount);\n            });\n        });\n    }\n\n    /**\n     * Delete many documents by query\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    deleteMany(collection, query) {\n        const that = this;\n        query = castQueryIds(query);\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n            db.deleteMany(query, {w:1}, function (error, result) {\n                if (error) return reject(error);\n                return resolve(result.deletedCount);\n            });\n        });\n    }\n\n    /**\n     * Find one document\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    findOne(collection, query) {\n        const that = this;\n        query = castQueryIds(query);\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n            db.findOne(query, function (error, doc) {\n                if (error) return reject(error);\n                return resolve(doc);\n            });\n        });\n    }\n\n    /**\n     * Find one document and update it\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} values\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    findOneAndUpdate(collection, query, values, options) {\n        const that = this;\n        query = castQueryIds(query);\n        if (!options) {\n            options = {};\n        }\n\n        // Always return the updated object\n        options.returnOriginal = false;\n\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n\n            let update = values;\n            if (options.upsert) {\n                update = { $setOnInsert: update };\n            } else {\n                update = { $set: update };\n            }\n\n            db.findOneAndUpdate(query, update, options, function(error, result) {\n                if (error) return reject(error);\n                resolve(result.value);\n            });\n        });\n    }\n\n    /**\n     * Find one document and delete it\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    findOneAndDelete(collection, query, options) {\n        const that = this;\n        query = castQueryIds(query);\n        if (!options) {\n            options = {};\n        }\n\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n\n            db.findOneAndDelete(query, options, function (error, result) {\n                if (error) return reject(error);\n                return resolve(result.value === null ? 0 : 1);\n            });\n        });\n    }\n\n    /**\n     * Find documents\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    find(collection, query, options) {\n        const that = this;\n        query = castQueryIds(query);\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n            let cursor = db.find(query);\n            if (options.sort && (_.isArray(options.sort) || _.isString(options.sort))) {\n                let sortOptions = {};\n                if (!_.isArray(options.sort)) {\n                    options.sort = [options.sort];\n                }\n\n                options.sort.forEach(function(s) {\n                    if (!_.isString(s)) return;\n\n                    let sortOrder = 1;\n                    if (s[0] === '-') {\n                        sortOrder = -1;\n                        s = s.substring(1);\n                    }\n                    sortOptions[s] = sortOrder;\n                });\n\n                cursor = cursor.sort(sortOptions);\n            }\n            if (typeof options.skip === 'number') {\n                cursor = cursor.skip(options.skip);\n            }\n            if (typeof options.limit === 'number') {\n                cursor = cursor.limit(options.limit);\n            }\n            cursor.toArray(function(error, docs) {\n                if (error) return reject(error);\n                return resolve(docs);\n            });\n        });\n    }\n\n    /**\n     * Count number of matching documents in the db to a query.\n     *\n     * @param {String} collection Collection's name\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    count(collection, query) {\n        const that = this;\n        query = castQueryIds(query);\n        return new Promise(function(resolve, reject) {\n            const db = that._mongo.collection(collection);\n            db.count(query, function (error, count) {\n                if (error) return reject(error);\n                return resolve(count);\n            });\n        });\n    }\n\n    /**\n     * Create index\n     *\n     * @param {String} collection Collection's name\n     * @param {String} field Field name\n     * @param {Object} options Options\n     * @returns {Promise}\n     */\n    createIndex(collection, field, options) {\n        options = options || {};\n        options.unique = options.unique || false;\n        options.sparse = options.sparse || false;\n        \n        const db = this._mongo.collection(collection);\n\n        let keys = {};\n        keys[field] = 1;\n        db.createIndex(keys, {unique: options.unique, sparse: options.sparse});\n    }\n\n    /**\n     * Connect to database\n     *\n     * @param {String} url\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    static connect(url, options) {\n        if (typeof(options) === 'undefined') {\n            options = { };\n        }\n        return new Promise(function(resolve, reject) {\n            MDBClient.connect(url, options, function(error, client) {\n                if (error) return reject(error);\n                return resolve(new MongoClient(url, client));\n            });\n        });\n    }\n\n    /**\n     * Close current connection\n     *\n     * @returns {Promise}\n     */\n    close() {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            that._mongo.close(function(error) {\n                if (error) return reject(error);\n                return resolve();\n            });\n        });\n    }\n\n    /**\n     * Drop collection\n     *\n     * @param {String} collection\n     * @returns {Promise}\n     */\n    clearCollection(collection) {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            that._mongo.dropCollection(collection, function(error, result) {\n                if (error) return reject(error);\n                return resolve();\n            });\n        });\n    }\n\n    /**\n     * Drop current database\n     *\n     * @returns {Promise}\n     */\n    dropDatabase() {\n        const that = this;\n        return new Promise(function(resolve, reject) {\n            that._mongo.dropDatabase(function(error, result) {\n                if (error) return reject(error);\n                return resolve();\n            });\n        });\n    }\n\n    /**\n     * Convert ObjectId to canonical form\n     *\n     * @param {ObjectId} id\n     * @returns {*|string|String}\n     */\n    toCanonicalId(id) {\n        return id.toString();\n    }\n\n    /**\n     * Is Native ID\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    isNativeId(value) {\n        return value instanceof ObjectId || String(value).match(/^[a-fA-F0-9]{24}$/) !== null;\n    }\n\n    nativeIdType() {\n        return ObjectId;\n    }\n\n    driver() {\n        return this._mongo;\n    }\n\n}\n\nconst castId = function(val) {\n    return new ObjectId(val);\n};\n\nconst castIdArray = function(vals) {\n    return vals.map(function(v) {\n        return castId(v);\n    });\n};\n\n/**\n * Traverses query and converts all IDs to MongoID\n *\n * TODO: Should we check for $not operator?\n *\n * @param {Object} query\n * @returns {Object}\n */\nconst castQueryIds = function(query) {\n    deepTraverse(query, function(key, val, parent) {\n        if (key === '_id') {\n            if (String(parent[key]).match(/^[a-fA-F0-9]{24}$/)) {\n                parent[key] = castId(parent[key]);\n            } else if (isObject(parent[key]) && _.has(parent[key], '$in')) {\n                // { _id: { '$in': [ 'K1cbMk7T8A0OU83IAT4dFa91', 'Y1cbak7T8A1OU83IBT6aPq11' ] } }\n                parent[key].$in = castIdArray(parent[key].$in);\n            } else if (isObject(parent[key]) && _.has(parent[key], '$nin')) {\n                // { _id: { '$nin': [ 'K1cbMk7T8A0OU83IAT4dFa91', 'Y1cbak7T8A1OU83IBT6aPq11' ] } }\n                parent[key].$nin = castIdArray(parent[key].$nin);\n            }\n        }\n    });\n\n    return query;\n};\n\nmodule.exports = MongoClient;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/validate.js":"'use strict';\n\nconst _ = require('lodash');\nconst DB = require('./clients').getClient;\n\nconst isString = function(s) {\n    return _.isString(s);\n};\n\nconst isNumber = function(n) {\n    return _.isNumber(n) && _.isFinite(n) && !isString(n);\n};\n\nconst isBoolean = function(b) {\n    return _.isBoolean(b);\n};\n\nconst isDate = function(d) {\n    return isNumber(d) || _.isDate(d) || isNumber(Date.parse(d));\n};\n\nconst isBuffer = function(b) {\n    return typeof b === 'object' || b instanceof Buffer;\n};\n\nconst isObject = function(o) {\n    return _.isObject(o);\n};\n\nconst isArray = function(a) {\n    return _.isArray(a);\n};\n\nconst isDocument = function(m) {\n    return m && m.documentClass && m.documentClass() === 'document';\n};\n\nconst isEmbeddedDocument = function(e) {\n    return e && e.documentClass && e.documentClass() === 'embedded';\n};\n\nconst isReferenceable = function(r) {\n    return isDocument(r) || isNativeId(r);\n};\n\nconst isNativeId = function(n) {\n    return DB().isNativeId(n);\n};\n\nconst isSupportedType = function(t) {\n    return (t === String || t === Number || t === Boolean ||\n            t === Buffer || t === Date || t === Array ||\n            isArray(t) || t === Object || t instanceof Object ||\n            typeof(t.documentClass) === 'function');\n};\n\nconst isType = function(value, type) {\n    if (type === String) {\n        return isString(value);\n    } else if (type === Number) {\n        return isNumber(value);\n    } else if (type === Boolean) {\n        return isBoolean(value);\n    } else if (type === Buffer) {\n        return isBuffer(value);\n    } else if (type === Date) {\n        return isDate(value);\n    } else if (type === Array || isArray(type)) {\n        return isArray(value);\n    } else if (type === Object) {\n        return isObject(value);\n    } else if (type.documentClass && type.documentClass() === 'document') {\n        return isDocument(value) || DB().isNativeId(value);\n    } else if (type.documentClass && type.documentClass() === 'embedded') {\n        return isEmbeddedDocument(value);\n    } else if (type === DB().nativeIdType()) {\n        return isNativeId(value);\n    } else {\n        throw new Error('Unsupported type: ' + type.name);\n    }\n};\n\nconst isValidType = function(value, type) {\n    // NOTE\n    // Maybe look at this: \n    // https://github.com/Automattic/mongoose/tree/master/lib/types\n\n    // TODO: For now, null is okay for all types. May\n    // want to specify in schema using 'nullable'?\n    if (value === null) return true;\n\n    // Issue #9: To avoid all model members being stored\n    // in DB, allow undefined to be assigned. If you want\n    // unassigned members in DB, use null.\n    if (value === undefined) return true;\n\n    // Arrays take a bit more work\n    if (type === Array || isArray(type)) {\n        // Validation for types of the form [String], [Number], etc\n        if (isArray(type) && type.length > 1) {\n            throw new Error('Unsupported type. Only one type can be specified in arrays, but multiple found:', + type);\n        }\n\n        if (isArray(type) && type.length === 1 && isArray(value)) {\n            let arrayType = type[0];\n            for (let i = 0; i < value.length; i++) {\n                let v = value[i];\n                if (!isType(v, arrayType)) {\n                    return false;\n                }\n            }\n        } else if (isArray(type) && type.length === 0 && !isArray(value)) {\n            return false;\n        } else if (type === Array && !isArray(value)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return isType(value, type);\n};\n\nconst isInChoices = function(choices, choice) {\n    if (!choices) {\n        return true;\n    }\n    return choices.indexOf(choice) > -1;\n};\n\nconst isEmptyValue = function(value) {\n    return typeof value === 'undefined' || (!(typeof value === 'number' || value instanceof Date || typeof value === 'boolean')\n        && (0 === Object.keys(value).length));\n};\n\nexports.isString = isString;\nexports.isNumber = isNumber;\nexports.isBoolean = isBoolean;\nexports.isDate = isDate;\nexports.isBuffer = isBuffer;\nexports.isObject = isObject;\nexports.isArray = isArray;\nexports.isDocument = isDocument;\nexports.isEmbeddedDocument = isEmbeddedDocument;\nexports.isReferenceable = isReferenceable;\nexports.isNativeId = isNativeId;\nexports.isSupportedType = isSupportedType;\nexports.isType = isType;\nexports.isValidType = isValidType;\nexports.isInChoices = isInChoices;\nexports.isEmptyValue = isEmptyValue;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/clients/index.js":"'use strict';\n\nconst assertConnected = function(db) {\n    if (db === null || db === undefined) {\n        throw new Error('You must first call \\'connect\\' before loading/saving documents.');\n    }\n};\n\nexports.getClient = function() {\n    const client = global.CLIENT;\n    assertConnected(client);\n    return client;\n};","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/util.js":"'use strict';\n\nconst deepTraverse = function(obj, func) {\n    for (let i in obj) {\n        func.apply(this, [i, obj[i], obj]);  \n        if (obj[i] !== null && typeof(obj[i]) == 'object') {\n            deepTraverse(obj[i], func);\n        }\n    }\n};\n\nexports.deepTraverse = deepTraverse;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/document.js":"'use strict';\n\nconst _ = require('lodash');\nconst deprecate = require('depd')('camo');\nconst DB = require('./clients').getClient;\nconst BaseDocument = require('./base-document');\nconst isSupportedType = require('./validate').isSupportedType;\nconst isArray = require('./validate').isArray;\nconst isReferenceable = require('./validate').isReferenceable;\nconst isEmbeddedDocument = require('./validate').isEmbeddedDocument;\nconst isString = require('./validate').isString;\n\nclass Document extends BaseDocument {\n    constructor(name) {\n        super();\n\n        if (name !== undefined && name !== null) {\n            deprecate('Document.constructor(name) - override Document.collectionName() instead');\n            this._meta = {\n                collection: name\n            };\n        }\n    }\n\n    // TODO: Is there a way to tell if a class is\n    // a subclass of something? Until I find out\n    // how, we'll be lazy use this.\n    static documentClass() {\n        return 'document';\n    }\n\n    documentClass() {\n        return 'document';\n    }\n\n    get meta() {\n        return this._meta;\n    }\n\n    set meta(meta) {\n        this._meta = meta;\n    }\n\n    /**\n     * Save (upsert) current document\n     *\n     * TODO: The method is too long and complex, it is necessary to divide...\n     * @returns {Promise}\n     */\n    save() {\n        const that = this;\n\n        let preValidatePromises = this._getHookPromises('preValidate');\n\n        return Promise.all(preValidatePromises).then(function() {\n\n            // Ensure we at least have defaults set\n\n            // TODO: We already do this on .create(), so\n            // should it really be done again?\n            _.keys(that._schema).forEach(function(key) {\n                if (!(key in that._schema)) {\n                    that[key] = that.getDefault(key);\n                }\n            });\n\n            // Validate the assigned type, choices, and min/max\n            that.validate();\n\n            // Ensure all data types are saved in the same encodings\n            that.canonicalize();\n\n            return Promise.all(that._getHookPromises('postValidate'));\n        }).then(function() {\n            return Promise.all(that._getHookPromises('preSave'));\n        }).then(function() {\n\n            // TODO: We should instead track what has changed and\n            // only update those values. Maybe make that._changed\n            // object to do this.\n            // Also, this might be really slow for objects with\n            // lots of references. Figure out a better way.\n            let toUpdate = that._toData({_id: false});\n\n            // Reference our objects\n            _.keys(that._schema).forEach(function(key) {\n                // Never care about _id\n                if (key === '_id') return;\n\n                if (isReferenceable(that[key]) ||            // isReferenceable OR\n                    (isArray(that[key]) &&              // isArray AND contains value AND value isReferenceable\n                    that[key].length > 0 &&\n                    isReferenceable(that[key][0]))) {\n\n                    // Handle array of references (ex: { type: [MyObject] })\n                    if (isArray(that[key])) {\n                        toUpdate[key] = [];\n                        that[key].forEach(function(v) {\n                            if (DB().isNativeId(v)) {\n                                toUpdate[key].push(v);\n                            } else {\n                                toUpdate[key].push(v._id);\n                            }\n                        });\n                    } else {\n                        if (DB().isNativeId(that[key])) {\n                            toUpdate[key] = that[key];\n                        } else {\n                            toUpdate[key] = that[key]._id;\n                        }\n                    }\n\n                }\n            });\n\n            // Replace EmbeddedDocument references with just their data\n            _.keys(that._schema).forEach(function(key) {\n                if (isEmbeddedDocument(that[key]) ||               // isEmbeddedDocument OR\n                    (isArray(that[key]) &&              // isArray AND contains value AND value isEmbeddedDocument\n                    that[key].length > 0 &&\n                    isEmbeddedDocument(that[key][0]))) {\n\n                    // Handle array of references (ex: { type: [MyObject] })\n                    if (isArray(that[key])) {\n                        toUpdate[key] = [];\n                        that[key].forEach(function(v) {\n                            toUpdate[key].push(v._toData());\n                        });\n                    } else {\n                        toUpdate[key] = that[key]._toData();\n                    }\n\n                }\n            });\n\n            return DB().save(that.collectionName(), that._id, toUpdate);\n        }).then(function(id) {\n            if (that._id === null) {\n                that._id = id;\n            }\n        }).then(function() {\n            // TODO: hack?\n            let postSavePromises = that._getHookPromises('postSave');\n            return Promise.all(postSavePromises);\n        }).then(function() {\n            return that;\n        }).catch(function(error) {\n            return Promise.reject(error);\n        });\n    }\n\n    /**\n     * Delete current document\n     *\n     * @returns {Promise}\n     */\n    delete() {\n        const that = this;\n        \n        let preDeletePromises = that._getHookPromises('preDelete');\n\n        return Promise.all(preDeletePromises).then(function() {\n            return DB().delete(that.collectionName(), that._id);\n        }).then(function(deleteReturn) {\n            // TODO: hack?\n            let postDeletePromises = [deleteReturn].concat(that._getHookPromises('postDelete'));\n            return Promise.all(postDeletePromises);\n        }).then(function(prevData) {\n            let deleteReturn = prevData[0];\n            return deleteReturn;\n        });\n    }\n\n    /**\n     * Delete one document in current collection\n     *\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    static deleteOne(query) {\n        return DB().deleteOne(this.collectionName(), query);\n    }\n\n    /**\n     * Delete many documents in current collection\n     *\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    static deleteMany(query) {\n        if (query === undefined || query === null) {\n            query = {};\n        }\n        \n        return DB().deleteMany(this.collectionName(), query);\n    }\n\n    /**\n     * @deprecated Use `findOne`\n     */\n    static loadOne(query, options) {\n        deprecate('loadOne - use findOne instead');\n        return this.findOne(query, options);\n    }\n\n    /**\n     * Find one document in current collection\n     *\n     * TODO: Need options to specify whether references should be loaded\n     *\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    static findOne(query, options) {\n        const that = this;\n\n        let populate = true;\n        if (options && options.hasOwnProperty('populate')) {\n            populate = options.populate;\n        }\n\n        return DB().findOne(this.collectionName(), query)\n        .then(function(data) {\n            if (!data) {\n                return null;\n            }\n\n            let doc = that._fromData(data);\n            if (populate === true || (isArray(populate) && populate.length > 0)) {\n                return that.populate(doc, populate);\n            }\n\n            return doc;\n        }).then(function(docs) {\n            if (docs) {\n                return docs;\n            }\n            return null;\n        });\n    }\n\n    /**\n     * @deprecated Use `findOneAndUpdate`\n     */\n    static loadOneAndUpdate(query, values, options) {\n        deprecate('loadOneAndUpdate - use findOneAndUpdate instead');\n        return this.findOneAndUpdate(query, values, options);\n    }\n\n    /**\n     * Find one document and update it in current collection\n     *\n     * @param {Object} query Query\n     * @param {Object} values\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    static findOneAndUpdate(query, values, options) {\n        const that = this;\n\n        if (arguments.length < 2) {\n            throw new Error('findOneAndUpdate requires at least 2 arguments. Got ' + arguments.length + '.');\n        }\n\n        if (!options) {\n            options = {};\n        }\n\n        let populate = true;\n        if (options.hasOwnProperty('populate')) {\n            populate = options.populate;\n        }\n\n        return DB().findOneAndUpdate(this.collectionName(), query, values, options)\n        .then(function(data) {\n            if (!data) {\n                return null;\n            }\n\n            let doc = that._fromData(data);\n            if (populate) {\n                return that.populate(doc);\n            }\n\n            return doc;\n        }).then(function(doc) {\n            if (doc) {\n                return doc;\n            }\n            return null;\n        });\n    }\n\n    /**\n     * @deprecated Use `findOneAndDelete`\n     */\n    static loadOneAndDelete(query, options) {\n        deprecate('loadOneAndDelete - use findOneAndDelete instead');\n        return this.findOneAndDelete(query, options);\n    }\n\n    /**\n     * Find one document and delete it in current collection\n     *\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    static findOneAndDelete(query, options) {\n        const that = this;\n\n        if (arguments.length < 1) {\n            throw new Error('findOneAndDelete requires at least 1 argument. Got ' + arguments.length + '.');\n        }\n\n        if (!options) {\n            options = {};\n        }\n\n        return DB().findOneAndDelete(this.collectionName(), query, options);\n    }\n\n    /**\n     * @deprecated Use `find`\n     */\n    static loadMany(query, options) {\n        deprecate('loadMany - use find instead');\n        return this.find(query, options);\n    }\n\n    /**\n     * Find documents\n     *\n     * TODO: Need options to specify whether references should be loaded\n     *\n     * @param {Object} query Query\n     * @param {Object} options\n     * @returns {Promise}\n     */\n    static find(query, options) {\n        const that = this;\n\n        if (query === undefined || query === null) {\n            query = {};\n        }\n\n        if (options === undefined || options === null) {\n            // Populate by default\n            options = {populate: true};\n        }\n\n        return DB().find(this.collectionName(), query, options)\n        .then(function(datas) {\n            let docs = that._fromData(datas);\n\n            if (options.populate === true ||\n                (isArray(options.populate) && options.populate.length > 0)) {\n                return that.populate(docs, options.populate);\n            }\n\n            return docs;\n        }).then(function(docs) {\n            // Ensure we always return an array\n            return [].concat(docs);\n        });\n    }\n\n    /**\n     * Get count documents in current collection by query\n     *\n     * @param {Object} query Query\n     * @returns {Promise}\n     */\n    static count(query) {\n        const that = this;\n        return DB().count(this.collectionName(), query);\n    }\n\n    /**\n     * Create indexes\n     *\n     * @returns {Promise}\n     */\n    static createIndexes() {\n        if (this._indexesCreated) {\n            return;\n        }\n\n        const that = this;\n        let instance = this._instantiate();\n\n        _.keys(instance._schema).forEach(function(k) {\n            if (instance._schema[k].unique) {\n                DB().createIndex(that.collectionName(), k, {unique: true});\n            }\n        });\n\n        this._indexesCreated = true;\n    }\n\n    static _fromData(datas) {\n        let instances = super._fromData(datas);\n        // This way we preserve the original structure of the data. Data\n        // that was passed as an array is returned as an array, and data\n        // passes as a single object is returned as single object\n        let datasArray = [].concat(datas);\n        let instancesArray = [].concat(instances);\n\n        /*for (let i = 0; i < instancesArray.length; i++) {\n            if (datasArray[i].hasOwnProperty('_id')) {\n                instancesArray[i]._id = datasArray[i]._id;\n            } else {\n                instancesArray[i]._id = null;\n            }\n        }*/\n        \n        return instances;\n    }\n\n    /**\n     * Clear current collection\n     *\n     * @returns {Promise}\n     */\n    static clearCollection() {\n        return DB().clearCollection(this.collectionName());\n    }\n    \n}\n\nmodule.exports = Document;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/base-document.js":"'use strict';\n\nconst _ = require('lodash');\nconst deprecate = require('depd')('camo');\nconst DB = require('./clients').getClient;\nconst isSupportedType = require('./validate').isSupportedType;\nconst isValidType = require('./validate').isValidType;\nconst isEmptyValue = require('./validate').isEmptyValue;\nconst isInChoices = require('./validate').isInChoices;\nconst isArray = require('./validate').isArray;\nconst isDocument = require('./validate').isDocument;\nconst isEmbeddedDocument = require('./validate').isEmbeddedDocument;\nconst isString = require('./validate').isString;\nconst isNumber = require('./validate').isNumber;\nconst isDate = require('./validate').isDate;\nconst ValidationError = require('./errors').ValidationError;\n\nconst normalizeType = function(property) {\n    // TODO: Only copy over stuff we support\n\n    let typeDeclaration = {};\n    if (property.type) {\n        typeDeclaration = property;\n    } else if (isSupportedType(property)) {\n        typeDeclaration.type = property;\n    } else {\n        throw new Error('Unsupported type or bad variable. ' + \n            'Remember, non-persisted objects must start with an underscore (_). Got:', property);\n    }\n\n    return typeDeclaration;\n};\n\nclass BaseDocument {\n    constructor() {\n        this._schema = {                            // Defines document structure/properties\n            _id: { type: DB().nativeIdType() },     // Native ID to backend database\n        };\n\n        this._id = null;\n    }\n\n    // TODO: Is there a way to tell if a class is\n    // a subclass of something? Until I find out\n    // how, we'll be lazy use this.\n    static documentClass() {\n        throw new TypeError('You must override documentClass (static).');\n    }\n\n    documentClass() {\n        throw new TypeError('You must override documentClass.');\n    }\n\n    collectionName() {\n        // DEPRECATED\n        // Getting ready to remove this functionality\n        if (this._meta) {\n            return this._meta.collection;\n        }\n\n        return this.constructor.collectionName();\n    }\n\n    /**\n     * Get current collection name\n     *\n     * @returns {String}\n     */\n    static collectionName() {\n        // DEPRECATED\n        // Getting ready to remove this functionality\n        let instance = new this();\n        if (instance._meta) {\n            return instance._meta.collection;\n        }\n\n        return this.name.toLowerCase() + 's';\n    }\n\n    get id() {\n        deprecate('Document.id - use Document._id instead');\n        return this._id;\n    }\n\n    set id(id) {\n        deprecate('Document.id - use Document._id instead');\n        this._id = id;\n    }\n\n    /**\n     * set schema\n     * @param {Object} extension\n     */\n    schema(extension) {\n        const that = this;\n\n        if (!extension) return;\n        _.keys(extension).forEach(function(k) {\n            that[k] = extension[k];\n        });\n    }\n\n    /*\n     * Pre/post Hooks\n     *\n     * To add a hook, the extending class just needs\n     * to override the appropriate hook method below.\n     */\n\n    preValidate() { }\n\n    postValidate() { }\n\n    preSave() { }\n\n    postSave() { }\n\n    preDelete() { }\n\n    postDelete() { }\n\n    /**\n     * Generate this._schema from fields\n     *\n     * TODO : EMBEDDED\n     * Need to share this with embedded\n     */\n    generateSchema() {\n        const that = this;\n\n        _.keys(this).forEach(function(k) {\n            // Ignore private variables\n            if (_.startsWith(k, '_')) {\n                return;\n            }\n\n            // Normalize the type format\n            that._schema[k] = normalizeType(that[k]);\n\n            // Assign a default if needed\n            if (isArray(that._schema[k].type)) {\n                that[k] = that.getDefault(k) || [];\n            } else {\n                that[k] = that.getDefault(k);\n            }\n        });\n    }\n\n    /**\n     * Validate current document\n     *\n     * The method throw errors if document has invalid value\n     *\n     * TODO: This is not the right approach. The method needs to collect all\n     * errors in array and return them.\n     */\n    validate() {\n        const that = this;\n\n        _.keys(that._schema).forEach(function(key) {\n            let value = that[key];\n\n            // TODO: This should probably be in Document, not BaseDocument\n            if (value !== null && value !== undefined) {\n                if (isEmbeddedDocument(value)) {\n                    value.validate();\n                    return;\n                } else if (isArray(value) && value.length > 0 && isEmbeddedDocument(value[0])) {\n                    value.forEach(function(v) {\n                        if (v.validate) {\n                            v.validate();\n                        }\n                    });\n                    return;\n                }\n            }\n\n            if (!isValidType(value, that._schema[key].type)) {\n                // TODO: Formatting should probably be done somewhere else\n                let typeName = null;\n                let valueName = null;\n                if (Array.isArray(that._schema[key].type) && that._schema[key].type.length > 0) {\n                    typeName = '[' + that._schema[key].type[0].name + ']';\n                } else if (Array.isArray(that._schema[key].type) && that._schema[key].type.length === 0) {\n                    typeName = '[]';\n                } else {\n                    typeName = that._schema[key].type.name;\n                }\n\n                if (Array.isArray(value)) {\n                    // TODO: Not descriptive enough! Strings can look like numbers\n                    valueName = '[' + value.toString() + ']';\n                } else {\n                    valueName = typeof(value);\n                }\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' should be ' + typeName + ', got ' + valueName);\n            }\n\n            if (that._schema[key].required && isEmptyValue(value)) {\n                throw new ValidationError('Key ' + that.collectionName() + '.' + key +\n                    ' is required' + ', but got ' + value);\n            }\n\n            if (that._schema[key].match && isString(value) && !that._schema[key].match.test(value)) {\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' does not match the regex/string ' + that._schema[key].match.toString() + '. Value was ' + value);\n            }\n\n            if (!isInChoices(that._schema[key].choices, value)) {\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' should be in choices [' + that._schema[key].choices.join(', ') + '], got ' + value);\n            }\n\n            if (isNumber(that._schema[key].min) && value < that._schema[key].min) {\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' is less than min, ' + that._schema[key].min + ', got ' + value);\n            }\n\n            if (isNumber(that._schema[key].max) && value > that._schema[key].max) {\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' is less than max, ' + that._schema[key].max + ', got ' + value);\n            }\n\n            if (typeof(that._schema[key].validate) === 'function' && !that._schema[key].validate(value)) {\n                throw new ValidationError('Value assigned to ' + that.collectionName() + '.' + key +\n                    ' failed custom validator. Value was ' + value);\n            }\n        });\n    }\n\n    /*\n     * Right now this only canonicalizes dates (integer timestamps\n     * get converted to Date objects), but maybe we should do the\n     * same for strings (UTF, Unicode, ASCII, etc)?\n     */\n    canonicalize() {\n        const that = this;\n\n        _.keys(that._schema).forEach(function(key) {\n            let value = that[key];\n            \n            if (that._schema[key].type === Date && isDate(value)) {\n                that[key] = new Date(value);\n            } else if (value !== null && value !== undefined && \n                value.documentClass && value.documentClass() === 'embedded') {\n                // TODO: This should probably be in Document, not BaseDocument\n                value.canonicalize();\n                return;\n            }\n        });\n    }\n\n    /**\n     * Create new document from data\n     *\n     * @param {Object} data\n     * @returns {Document}\n     */\n    static create(data) {\n        this.createIndexes();\n\n        if (typeof(data) !== 'undefined') {\n            return this._fromData(data);\n        }\n\n        return this._instantiate();\n    }\n\n    static createIndexes() { }\n\n    /**\n     * Create new document from self\n     *\n     * @returns {BaseDocument}\n     * @private\n     */\n    static _instantiate() {\n        let instance = new this();\n        instance.generateSchema();\n        return instance;\n    }\n\n    // TODO: Should probably move some of this to \n    // Embedded and Document classes since Base shouldn't\n    // need to know about child classes\n    static _fromData(datas) {\n        const that = this;\n\n        if (!isArray(datas)) {\n            datas = [datas];\n        }\n\n        let documents = [];\n        let embeddedPromises = [];\n        datas.forEach(function(d) {\n            let instance = that._instantiate();\n            _.keys(d).forEach(function(key) {\n                let value = null;\n                if (d[key] === null) {\n                    value = instance.getDefault(key);\n                } else {\n                    value = d[key];\n                }\n\n                // If its not in the schema, we don't care about it... right?\n                if (key in instance._schema) {\n\n                    let type = instance._schema[key].type;\n\n                    if (type.documentClass && type.documentClass() === 'embedded') {\n                        // Initialize EmbeddedDocument\n                        instance[key] = type._fromData(value);\n                    } else if (isArray(type) && type.length > 0 && \n                        type[0].documentClass && type[0].documentClass() === 'embedded') {\n                        // Initialize array of EmbeddedDocuments\n                        instance[key] = [];\n                        value.forEach(function(v, i) {\n                            instance[key][i] = type[0]._fromData(v);\n                        });\n                    } else {\n                        // Initialize primitive or array of primitives\n                        instance[key] = value;\n                    }\n                } else if (key in instance) {\n                    // Handles virtual setters\n                    instance[key] = value;\n                }\n            });\n\n            documents.push(instance);\n        });\n\n        if (documents.length === 1) {\n            return documents[0];\n        }\n        return documents;\n    }\n\n    populate() {\n        return BaseDocument.populate(this);\n    }\n\n    /**\n     * Populates document references\n     *\n     * TODO : EMBEDDED\n     * @param {Array|Document} docs\n     * @param {Array} fields\n     * @returns {Promise}\n     */\n    static populate(docs, fields) {\n        if (!docs) return Promise.all([]);\n\n        let documents = null;\n\n        if (!isArray(docs)) {\n            documents = [docs];\n        } else if (docs.length < 1) {\n            return Promise.all(docs);\n        } else {\n            documents = docs;\n        }\n\n        // Load all 1-level-deep references\n        // First, find all unique keys needed to be loaded...\n        let keys = [];\n\n        // TODO: Bad assumption: Not all documents in the database will have the same schema...\n        // Hmm, if this is true, thats an error on the user. Right?\n        let anInstance = documents[0];\n\n        _.keys(anInstance._schema).forEach(function(key) {\n            // Only populate specified fields\n            if (isArray(fields) && fields.indexOf(key) < 0) {\n                return;\n            }\n\n            // Handle array of references (ex: { type: [MyObject] })\n            if (isArray(anInstance._schema[key].type) &&\n                anInstance._schema[key].type.length > 0 &&\n                isDocument(anInstance._schema[key].type[0])) {\n                keys.push(key);\n            }\n            // Handle anInstance[key] being a string id, a native id, or a Document instance\n            else if ((isString(anInstance[key]) || DB().isNativeId(anInstance[key])) &&\n                     isDocument(anInstance._schema[key].type)) {\n                keys.push(key);\n            }\n        });\n\n        // ...then get all ids for each type of reference to be loaded...\n        // ids = {\n        //      houses: {\n        //          'abc123': ['ak23lj', '2kajlc', 'ckajl32'],\n        //          'l2jo99': ['28dsa0']\n        //      },\n        //      friends: {\n        //          '1039da': ['lj0adf', 'k2jha']\n        //      }\n        //}\n        let ids = {};\n        keys.forEach(function(k) {\n            ids[k] = {};\n            documents.forEach(function(d) {\n                ids[k][DB().toCanonicalId(d._id)] = [].concat(d[k]);     // Handles values and arrays\n\n                // Also, initialize document member arrays\n                // to assign to later if needed\n                if (isArray(d[k])) {\n                    d[k] = [];\n                }\n            });\n        });\n\n        // TODO: Is this really the most efficient\n        // way to do this? Maybe make a master list\n        // of all objects that need to be loaded (separated\n        // by type), load those, and then search through\n        // ids to see where dereferenced objects should\n        // go?\n\n        // ...then for each array of ids, load them all...\n        let loadPromises = [];\n        _.keys(ids).forEach(function(key) {\n            let keyIds = [];\n            _.keys(ids[key]).forEach(function(k) {\n                // Before adding to list, we convert id to the\n                // backend database's native ID format.\n                keyIds = keyIds.concat(ids[key][k]);\n            });\n\n            // Only want to load each reference once\n            keyIds = _.unique(keyIds);\n\n            // Handle array of references (like [MyObject])\n            let type = null;\n            if (isArray(anInstance._schema[key].type)) {\n                type = anInstance._schema[key].type[0];\n            } else {\n                type = anInstance._schema[key].type;\n            }\n\n            // Bulk load dereferences\n            let p = type.find({ '_id': { $in: keyIds } }, { populate: false })\n            .then(function(dereferences) {\n                // Assign each dereferenced object to parent\n\n                _.keys(ids[key]).forEach(function(k) {\n                    // TODO: Replace with documents.find when able\n                    // Find the document to assign the derefs to\n                    let doc;\n                    documents.forEach(function(d) {\n                        if (DB().toCanonicalId(d._id) === k) doc = d;\n                    });\n\n                    // For all ids to be dereferenced, find the\n                    // deref and assign or push it\n                    ids[key][k].forEach(function(id) {\n                        // TODO: Replace with dereferences.find when able\n                        // Find the right dereference\n                        let deref;\n                        dereferences.forEach(function(d) {\n                            if (DB().toCanonicalId(d._id) === DB().toCanonicalId(id)) deref = d;\n                        });\n\n                        if (isArray(anInstance._schema[key].type)) {\n                            doc[key].push(deref);\n                        } else {\n                            doc[key] = deref;\n                        }\n                    });\n                });\n            });\n\n            loadPromises.push(p);\n        });\n\n        // ...and finally execute all promises and return our\n        // fully loaded documents.\n        return Promise.all(loadPromises).then(function() {\n            return docs;\n        });\n    }\n\n    /**\n     * Get default value\n     *\n     * @param {String} schemaProp Key of current schema\n     * @returns {*}\n     */\n    getDefault(schemaProp) {\n        if (schemaProp in this._schema && 'default' in this._schema[schemaProp]) {\n            let def = this._schema[schemaProp].default;\n            let defVal = typeof(def) === 'function' ? def() : def;\n            this[schemaProp] = defVal;  // TODO: Wait... should we be assigning it here?\n            return defVal;\n        } else if (schemaProp === '_id') {\n            return null;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * For JSON.Stringify\n     *\n     * @returns {*}\n     */\n    toJSON() {\n        let values = this._toData({_id: true});\n        let schema = this._schema;\n        for (let key in schema) {\n            if (schema.hasOwnProperty(key)) {\n                if (schema[key].private){\n                    delete values[key];\n                } else if (values[key] && values[key].toJSON) {\n                    values[key] = values[key].toJSON();\n                } else if (isArray(values[key])) {\n                    let newArray = [];\n                    values[key].forEach(function(i) {\n                        if (i && i.toJSON) {\n                            newArray.push(i.toJSON());\n                        } else {\n                            newArray.push(i);\n                        }\n                    });\n                    values[key] = newArray;\n                }\n            }\n        }\n\n        return values;\n    }\n\n    /**\n     *\n     * @param keep\n     * @returns {{}}\n     * @private\n     */\n    _toData(keep) {\n        const that = this;\n\n        if (keep === undefined || keep === null) {\n            keep = {};\n        } else if (keep._id === undefined) {\n            keep._id = true;\n        }\n\n        let values = {};\n        _.keys(this).forEach(function(k) {\n            if (_.startsWith(k, '_')) {\n                if (k !== '_id' || !keep._id) {\n                    return;\n                } else {\n                    values[k] = that[k];\n                }\n            } else if (isEmbeddedDocument(that[k])) {\n                values[k] = that[k]._toData();\n            } else if (isArray(that[k]) && that[k].length > 0 && isEmbeddedDocument(that[k][0])) {\n                values[k] = [];\n                that[k].forEach(function(v) {\n                    values[k].push(v._toData());\n                });\n            } else {\n                values[k] = that[k];\n            }\n        });\n\n        return values;\n    }\n\n    _getEmbeddeds() {\n        const that = this;\n\n        let embeddeds = [];\n        _.keys(this._schema).forEach(function(v) {\n            if (isEmbeddedDocument(that._schema[v].type) ||\n                (isArray(that._schema[v].type) && isEmbeddedDocument(that._schema[v].type[0]))) {\n                embeddeds = embeddeds.concat(that[v]);\n            }\n        });\n        return embeddeds;\n    }\n\n    _getHookPromises(hookName) {\n        let embeddeds = this._getEmbeddeds();\n\n        let hookPromises = [];\n        hookPromises = hookPromises.concat(_.invoke(embeddeds, hookName));\n        hookPromises.push(this[hookName]());\n        return hookPromises;\n    }\n}\n\nmodule.exports = BaseDocument;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/errors.js":"'use strict';\n\n/*\n * Base Camo error.\n * \n * Adapted from es6-error package.\n */\nclass CamoError extends Error {\n    constructor(message) {\n        super(message);\n\n        // Extending Error is weird and does not propagate `message`\n        Object.defineProperty(this, 'message', {\n            enumerable : false,\n            value : message\n        });\n\n        Object.defineProperty(this, 'name', {\n            enumerable : false,\n            value : this.constructor.name,\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            Error.captureStackTrace(this, this.constructor);\n            return;\n        }\n\n        Object.defineProperty(this, 'stack', {\n            enumerable : false,\n            value : (new Error(message)).stack,\n        });\n    }\n}\n\n/*\n * Error indicating document didn't pass validation.\n */\nclass ValidationError extends CamoError {\n    constructor(message) {\n        super(message);\n    }\n}\n\nexports.CamoError = CamoError;\nexports.ValidationError = ValidationError;","/home/travis/build/npmtest/node-npmtest-camo/node_modules/camo/lib/embedded-document.js":"'use strict';\n\nconst BaseDocument = require('./base-document');\n\nclass EmbeddedDocument extends BaseDocument {\n    constructor() {\n        super();\n\n        // TODO: Move _id logic out of BaseDocument.\n        // A better fix to this issue is to remove\n        // _schema._id and _id from BaseDocument. But\n        // since quite a bit of _id logic is still\n        // in BD, we'll have to use this fix until\n        // it is removed\n        delete this._schema._id;\n        delete this._id;\n    }\n\n    // TODO: Is there a way to tell if a class is\n    // a subclass of something? Until I find out\n    // how, we'll be lazy use this.\n    static documentClass() {\n        return 'embedded';\n    }\n\n    documentClass() {\n        return 'embedded';\n    }\n}\n\nmodule.exports = EmbeddedDocument;"}